/* Strahler_Analysis.bsh
 * IJ BAR: https://github.com/tferr/Scripts#scripts
 *
 * BeanShell script that performs Strahler analysis in ImageJ by repeated elimination of
 * terminal branches of topographic 2D/3D skeletons
 * Tiago Ferreira, v1.3.2 2014.11.18
 *
 * Requirements:
 * Ignacio Arganda-Carreras Skeletonize (http://fiji.sc/Skeletonize3D) and AnalyzeSkeleton
 * (http://fiji.sc/AnalyzeSkeleton) plugins, both bundled with Fiji (http://fiji.sc/)
 *
 * Installation:
 * Save this file in the plugins/ folder using the 'Plugins>Install...' command.
 *
 * Resources:
 * http://jenkins.imagej.net/job/Fiji-javadoc/javadoc/Skeletonize3D_/Skeletonize3D_.html
 * http://jenkins.imagej.net/job/Fiji-javadoc/javadoc/skeleton_analysis/package-summary.html
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software Foundation
 * (http://www.gnu.org/licenses/gpl.txt).
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 */

import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.WindowManager;
import ij.gui.GenericDialog;
import ij.gui.Roi;
import ij.plugin.ZProjector;
import ij.plugin.filter.ParticleAnalyzer;
import ij.measure.Calibration;
import ij.measure.ResultsTable;
import ij.process.ByteProcessor;
import ij.process.ImageProcessor;
import ij.text.TextWindow;

import skeleton_analysis.AnalyzeSkeleton_;
import skeleton_analysis.Point;
import skeleton_analysis.SkeletonResult;
import Skeletonize3D_.Skeletonize3D_;

import java.awt.Rectangle;
import java.util.ArrayList;


/* Default value for max. number of prunning cycles */
int maxPruning = 10;

/* Default option for loop detection */
int pruneChoice = AnalyzeSkeleton_.SHORTEST_BRANCH;

/* Default option for 'root-protection' ROI */
boolean protectRoot = true;

/* Default option for 'iteration-stack' output */
boolean outIS = false;

/* Default option for 'color map' output */
boolean outCM = false;

/* Default option for verbose mode */
boolean verbose = false;

/* Title of results window */
String STRAHLER_TABLE = "Strahler_Table";

/* Remove isolated pixels from thinned images? */
boolean erodeIsolatedPixels = true;

/* Flag for 'root-protective' ROI */
private static boolean validRootRoi;


/* Reminds the user to install required dependencies */
boolean validInstallation() {
	try {
		Class.forName("skeleton_analysis.AnalyzeSkeleton_");
		Class.forName("Skeletonize3D_.Skeletonize3D_");
		return true;
	} catch( ClassNotFoundException e ) {
		URL = "http://jenkins.imagej.net/job/Stable-Fiji/ws/Fiji.app/plugins/";
		AS_VRSN = "AnalyzeSkeleton_-2.0.3.jar";
		SK_VRSN = "Skeletonize3D_-1.0.1.jar";
		msg = "\n**** Strahler Analysis Error: Required file(s) not found:\n"+ e +"\n \n"
			+ "Strahler Analysis requires AnalyzeSkeleton_.jar and Skeletonize3D_.jar to be installed in\n"
			+ "the plugins/ folder. Please install the missing file(s) by double-clicking on the links below:\n \n"
			+ URL + AS_VRSN +"\n"+ URL + SK_VRSN;
		IJ.log(msg);
		return false;
	}
}

/*
 * Creates the dialog prompt, retrieving the image with the original structure. While it
 * is unlikely that the iterative pruning of terminal branches will cause new loops on
 * pre-existing skeletons, offering the option to resolve loops with intensity based
 * methods remains useful specially when analyzing non-thinned grayscale images.
 */
ImagePlus getOriginalImp(ImagePlus currentImp, String currentTitle) {

	ImagePlus origImg = currentImp;
	gd = new GenericDialog("Strahler Analysis of "+ currentTitle);
	headerFont = new Font("SansSerif", Font.BOLD, 12);

	// Part 1. Main Options
	gd.setInsets(0, 0, 0);
	gd.addMessage("Strahler Numbering:", headerFont);
	gd.addSlider("     Max. n. of iterations:", 1, 20, super.maxPruning);
	gd.addCheckbox("Infer root end-points from rectangular ROI", super.protectRoot);
	gd.addCheckbox("Ignore single-point arbors (Isolated pixels)", super.erodeIsolatedPixels);
	if (!super.validRootRoi) {
		Checkbox roiOption = (Checkbox)gd.getCheckboxes().elementAt(0);
		roiOption.setEnabled(false);
	}

	// Part 2: Loop elimination
	gd.setInsets(25, 0, 0);
	gd.addMessage("Elimination of Skeleton Loops:", headerFont);
	gd.addChoice("Method:", AnalyzeSkeleton_.pruneCyclesModes,
					AnalyzeSkeleton_.pruneCyclesModes[super.pruneChoice]);

	int[] ids = WindowManager.getIDList();
	String[] imgTitles = new String[ids.length];
	for (int i=0; i<ids.length; ++i )
		imgTitles[i] = (WindowManager.getImage(ids[i])).getTitle();
	gd.addChoice("Unsegmented image:", imgTitles, null);

	boolean singleImage = (ids==null || ids.length<2);
	if (singleImage) {
		Choice methods = (Choice)gd.getChoices().elementAt(0);
		Choice images = (Choice)gd.getChoices().elementAt(1);
		methods.remove(AnalyzeSkeleton_.pruneCyclesModes[AnalyzeSkeleton_.LOWEST_INTENSITY_VOXEL]);
		methods.remove(AnalyzeSkeleton_.pruneCyclesModes[AnalyzeSkeleton_.LOWEST_INTENSITY_BRANCH]);
		images.setEnabled(false);
	}

	// Part 3: Output
	gd.setInsets(25, 0, 0);
	gd.addMessage("Output Options:", headerFont);
	gd.addCheckbox("Iteration stack (Document individual iterations)", super.outIS);
	gd.addCheckbox("Heat-map image (Summarize analysis)", super.outCM);
	gd.addCheckbox("Show detailed information (Verbose mode)", super.verbose);

	gd.addHelp("http://fiji.sc/Strahler");
	gd.showDialog();
	if (gd.wasCanceled()) return null;

	super.maxPruning = (int)gd.getNextNumber();
	super.protecRoot = gd.getNextBoolean();
	super.erodeIsolatedPixels = gd.getNextBoolean();
	super.pruneChoice = gd.getNextChoiceIndex();
	imgChoice = gd.getNextChoiceIndex();
	super.outIS = gd.getNextBoolean();
	super.outCM = gd.getNextBoolean();
	super.verbose = gd.getNextBoolean();

	return (singleImage) ? currentImp : WindowManager.getImage(ids[imgChoice]);
}

/* Returns the table of the specified window title */
ResultsTable getTable(String title) {
	ResultsTable rt = null;
	window = WindowManager.getFrame(title);
	if (window!=null)
		rt = ((TextWindow)window).getTextPanel().getResultsTable();
	if (rt==null)
		rt = new ResultsTable();
	return rt;
}

/* Returns the sum of elements of an int[] array */
int sum(int[] array) {
	int sum = 0;
	if (array!=null) for (int i : array) sum += i;
	return sum;
}

/* Returns the sum of elements of a double[] array */
double sum(double[] array) {
	double sum = 0;
	if (array!=null) for (double i : array) sum += i;
	return sum;
}

/*
 * Paints point positions. NB: BeanShell does not seem to suport generics. This triggers a
 * ParseException: paintPoints(ImageStack stack, ArrayList<Point> points, int value, String label)
 */
void paintPoints(ImageStack stack, points, int value, String sliceLabel) {
	if (points!=null) {
		ImageProcessor ip = ip.createProcessor(stack.getWidth(), stack.getHeight());
		for (int j=0; j<points.size(); j++) {
			Point point = points.get(j);
			ip.putPixel(point.x, point.y, value);
		}
		stack.addSlice(sliceLabel, ip);
	}
}

/*
 * Skeletonization method that erodes the thinned structure in order to eliminate
 * isolated pixels. Thinning and pruning may give rise to single point arbors.
 * These 'debris' trees have 1 end-point but no branches or junctions. If present
 * they overestimate the total number of end-points
 */
void skeletonizeWithoutHermits(ImagePlus imp) {
	Skeletonize3D_ thin = new Skeletonize3D_();
	thin.setup("", imp);
	thin.run(null);
	if (super.erodeIsolatedPixels) {
		ImageStack stack = imp.getStack();
		for (int i=1; i<=stack.getSize(); i++)
			((ByteProcessor)stack.getProcessor(i)).erode(8, 0);
	}
}


// Startup checks
if (!validInstallation())
	{ IJ.error("Missing files? See Log window for details."); return; }
ImagePlus srcImp = WindowManager.getCurrentImage();
if (srcImp==null)
	{ IJ.error("There are no images open."); return; }
if (srcImp.getBitDepth()!=8)
	{ IJ.error("Cannot process "+ srcImp.getTitle() +".\nOnly 8-bit images can be processed."); return; }

Roi roi = srcImp.getRoi();
validRootRoi = (roi!=null && roi.getType()==Roi.RECTANGLE);

// Prompt for options and retrieve image for intensity-based pruning of skel. loops
ImagePlus origImp = getOriginalImp(srcImp, title = srcImp.getTitle() );
if (origImp==null) return;

// Work on a copy, since the original image will be modified
if (roi!=null) srcImp.killRoi();
ImagePlus imp = srcImp.duplicate();
if (roi!=null) srcImp.setRoi(roi);
ImageProcessor ip = imp.getProcessor();

// Analyze root
ImageProcessor rootIp;
SkeletonResult rootResult;
ArrayList rootEndpointsList;

if (validRootRoi) {

	// Duplicate entire canvas. Ignore tree(s) outside ROI
	ImagePlus rootImp = imp.duplicate();
	rootIp = rootImp.getProcessor();
	rootIp.setValue(0.0);
	rootIp.fillOutside(roi);
	
	// Skeletonize, remove isolated pixels retrieve result
	skeletonizeWithoutHermits(rootImp);
	AnalyzeSkeleton_ root = new AnalyzeSkeleton_();
	root.setup("", rootImp);
	rootResult = root.run(pruneChoice, false, false, origImp, true, false);

	// Remove end-points at ROI boundaries
	rootEndpointsList = rootResult.getListOfEndPoints();
	Rectangle r = roi.getBounds();
	for (int i=0; i<rootEndpointsList.size(); i++) {
		Point p = rootEndpointsList.get(i);
		if (p.x==r.x+1 || p.y==r.y+1 || p.x==r.x+r.getWidth()-2 || p.y==r.y+r.getHeight()-2)
			rootEndpointsList.remove(i);
	}

}

// Initialize results table and display images. Use Z-projections
// to populate iteration stack when dealing with 3D skeletons
ResultsTable rt = getTable(STRAHLER_TABLE);
rt.setPrecision(5);

int nSlices = imp.getNSlices();
ImageStack newStack;
ZProjector zp;
if (outIS || outCM) {
	newStack = new ImageStack( imp.getWidth(), imp.getHeight() );
	if (nSlices>1) {
		zp = new ZProjector(imp);
		zp.setMethod(ZProjector.MAX_METHOD);
		zp.setStartSlice(1);
		zp.setStopSlice(nSlices);
	}
}

// Initialize AnalyzeSkeleton_, Skeletonize3D_
AnalyzeSkeleton_ skel = new AnalyzeSkeleton_();
skel.setup("", imp);

// Iterate through all the structures
int order = 1, nEndpoints = 0, nJunctions = 0, nJunctions2 = 0;
double nEndpoints2 = Double.NaN;
ArrayList endpointsList, junctionsList;

do {

	IJ.showStatus("Retrieving measurements for order "+ order +"...");
	IJ.showProgress(order, maxPruning);

	// (Re)skeletonize image
	skeletonizeWithoutHermits(imp);

	// Add current skeleton to debug animation
	if (outIS || outCM) {
		if (nSlices>1) {
			zp.doProjection();
			ipd = zp.getProjection().getProcessor();
		} else {
			ipd = ip.duplicate();
		}
		newStack.addSlice("Order "+ IJ.pad(order, 2), ipd);
	}

	// Get properties of loop-resolved structure
	SkeletonResult skelResult = skel.run(pruneChoice, false, false, origImp, true, false);
	nEndpoints = sum(skelResult.getEndPoints());
	nJunctions = sum(skelResult.getJunctions());

	// Retrieve initial properties
	if (order==1) {
		endpointsList = skelResult.getListOfEndPoints();
		junctionsList = skelResult.getListOfJunctionVoxels();
	}

	// Is it worth proceeding?
	if (nEndpoints==0) {
		rt.addValue("Notes", "No end-poins detected!");
		break;
	}
	if (nJunctions2==nJunctions) {
		rt.addValue("Notes", "Unsolved loop(s) detected!");
		break;
	}

	// Report counts
	rt.incrementCounter();
	rt.addLabel("Image", title);
	rt.addValue("Strahler order", Integer.toString(order));
	rt.addValue("# End-points", nEndpoints);
	rt.addValue("Ramification ratios", nEndpoints2/nEndpoints);
	rt.addValue("Notes", "");
	if (verbose) {
		rt.addValue("Average branch length", sum(skelResult.getAverageBranchLength()));
		rt.addValue("# Trees", skelResult.getNumOfTrees());
		rt.addValue("# Branches", sum(skelResult.getBranches()));
		rt.addValue("# Junctions", nJunctions);
		rt.addValue("# Triple points", sum(skelResult.getTriples()));
		rt.addValue("# Quadruple points", sum(skelResult.getQuadruples()));
	}

	// Remember main results
	nEndpoints2 = (double)nEndpoints;
	nJunctions2 = nJunctions;

	// Eliminate end-points
	skel.run(pruneChoice, true, false, null, true, false, roi);

} while (order++ <= maxPruning && nJunctions > 0);


// Append root properties to table
if (validRootRoi) {
	rt.incrementCounter();
	rt.addLabel("Image", title);
	rt.addValue("Strahler order", Integer.toString(order)+" (Root)");
	rt.addValue("# End-points", rootEndpointsList.size());
	rt.addValue("Ramification ratios", nEndpoints2/rootEndpointsList.size());
	rt.addValue("Notes", "Root-branches inferred from ROI");
	if (verbose) {
		rt.addValue("Average branch length", sum(rootResult.getAverageBranchLength()));
		rt.addValue("# Trees", rootResult.getNumOfTrees());
		rt.addValue("# Branches", sum(rootResult.getBranches()));
		rt.addValue("# Junctions", sum(rootResult.getJunctions()));
		rt.addValue("# Triple points", sum(rootResult.getTriples()));
		rt.addValue("# Quadruple points", sum(rootResult.getQuadruples()));
	}
}

// Create results image(s)
if (outIS || outCM) {
	ImagePlus imp2 = new ImagePlus("StrahlerAnimation_"+ title, newStack);
	Calibration cal = srcImp.getCalibration();
	if (outIS) {
		if (validRootRoi) {
			newStack.addSlice("Root", rootIp);
			paintPoints(newStack, rootEndpointsList, 255, "Root end-points");
			imp2.setRoi(roi);
		}
		paintPoints(newStack, endpointsList, 255, "End-points");
		paintPoints(newStack, junctionsList, 255, "Junction-points");
		imp2.show();
	}
	if (outCM) {
		zp = new ZProjector(imp2);
		zp.setMethod(ZProjector.SUM_METHOD);
		zp.setStartSlice(1);
		zp.setStopSlice(order-1);
		zp.doProjection();
		ImageProcessor ip3 = zp.getProjection().getProcessor();
		ip3.multiply(1/255.0);
		ip3.resetThreshold();
		ip3.setMinAndMax(0, order-1);
		ImagePlus imp3 = new ImagePlus("StrahlerMask_"+ title, ip3);
		IJ.run(imp3, "Fire", "");
		IJ.run(imp3, "Calibration Bar...", " overlay");
		if (validRootRoi) imp3.setRoi(roi);
		imp3.show();
	}
}

// Exit
rt.show(STRAHLER_TABLE);
IJ.showProgress(0, 0);
IJ.showTime(imp, imp.getStartTime(), "Strahler Analysis concluded... ");
